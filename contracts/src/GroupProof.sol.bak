// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/**
 * @title GroupProof
 * @author Shreya Srivastava
 * @notice Blockchain-based contribution tracker for group projects
 * @dev Stores git commits on Polygon for transparent contribution proof
 */
contract GroupProof {
    struct Commit {
        bytes32 commitHash;
        address author;
        string authorName;
        string authorEmail;
        uint256 timestamp;
        uint256 gitTimestamp;
        string message;
        uint16 filesChanged;
        uint32 additions;
        uint32 deletions;
        string repoName;
        string branch;
    }

    struct Project {
        string name;
        string description;
        address owner;
        uint256 createdAt;
        bool isActive;
        address[] contributors;
        uint256 commitCount;
    }

    struct ContributorStats {
        uint256 totalCommits;
        uint256 totalAdditions;
        uint256 totalDeletions;
        uint256 totalFilesChanged;
        uint256 firstContribution;
        uint256 lastContribution;
    }

    mapping(bytes32 => Project) public projects;
    mapping(bytes32 => Commit[]) private projectCommits;
    mapping(bytes32 => mapping(address => ContributorStats)) public contributorStats;
    mapping(bytes32 => mapping(bytes32 => bool)) public commitExists;
    mapping(address => bytes32[]) public userProjects;
    bytes32[] public allProjects;

    event ProjectCreated(bytes32 indexed projectId, string name, address indexed owner, uint256 timestamp);
    event CommitRecorded(bytes32 indexed projectId, bytes32 indexed commitHash, address indexed author, string authorName, uint256 timestamp, uint16 filesChanged, uint32 additions, uint32 deletions);
    event ProjectDeactivated(bytes32 indexed projectId, uint256 timestamp);

    function createProject(string calldata name, string calldata description) external returns (bytes32 projectId) {
        require(bytes(name).length > 0 && bytes(name).length <= 100, "Invalid name");
        projectId = keccak256(abi.encodePacked(name, msg.sender, block.timestamp));
        require(projects[projectId].createdAt == 0, "ID collision");

        Project storage p = projects[projectId];
        p.name = name;
        p.description = description;
        p.owner = msg.sender;
        p.createdAt = block.timestamp;
        p.isActive = true;
        p.contributors.push(msg.sender);

        allProjects.push(projectId);
        userProjects[msg.sender].push(projectId);
        emit ProjectCreated(projectId, name, msg.sender, block.timestamp);
    }

    function recordCommit(
        bytes32 projectId, bytes32 commitHash, string calldata authorName,
        string calldata authorEmail, uint256 gitTimestamp, string calldata message,
        uint16 filesChanged, uint32 additions, uint32 deletions,
        string calldata repoName, string calldata branch
    ) external {
        require(projects[projectId].isActive, "Inactive");
        require(!commitExists[projectId][commitHash], "Duplicate");

        projectCommits[projectId].push(Commit(commitHash, msg.sender, authorName, authorEmail, block.timestamp, gitTimestamp, message, filesChanged, additions, deletions, repoName, branch));
        commitExists[projectId][commitHash] = true;
        projects[projectId].commitCount++;

        ContributorStats storage s = contributorStats[projectId][msg.sender];
        if (s.firstContribution == 0) {
            s.firstContribution = block.timestamp;
            projects[projectId].contributors.push(msg.sender);
            userProjects[msg.sender].push(projectId);
        }
        s.totalCommits++;
        s.totalAdditions += additions;
        s.totalDeletions += deletions;
        s.totalFilesChanged += filesChanged;
        s.lastContribution = block.timestamp;

        emit CommitRecorded(projectId, commitHash, msg.sender, authorName, block.timestamp, filesChanged, additions, deletions);
    }

    function deactivateProject(bytes32 projectId) external {
        require(projects[projectId].owner == msg.sender, "Not owner");
        projects[projectId].isActive = false;
        emit ProjectDeactivated(projectId, block.timestamp);
    }

    function getProject(bytes32 projectId) external view returns (string memory, string memory, address, uint256, bool, uint256, uint256) {
        Project storage p = projects[projectId];
        return (p.name, p.description, p.owner, p.createdAt, p.isActive, p.contributors.length, p.commitCount);
    }

    function getCommits(bytes32 projectId, uint256 offset, uint256 limit) external view returns (Commit[] memory) {
        uint256 total = projectCommits[projectId].length;
        if (offset >= total) return new Commit[](0);
        uint256 end = offset + limit > total ? total : offset + limit;
        Commit[] memory result = new Commit[](end - offset);
        for (uint256 i = 0; i < end - offset; i++) result[i] = projectCommits[projectId][total - 1 - offset - i];
        return result;
    }

    function getContributorStats(bytes32 projectId, address contributor) external view returns (ContributorStats memory) {
        return contributorStats[projectId][contributor];
    }

    function getContributors(bytes32 projectId) external view returns (address[] memory) {
        return projects[projectId].contributors;
    }

    function getUserProjects(address user) external view returns (bytes32[] memory) {
        return userProjects[user];
    }

    function getTotalProjects() external view returns (uint256) { return allProjects.length; }

    function getAllProjects(uint256 offset, uint256 limit) external view returns (bytes32[] memory) {
        uint256 total = allProjects.length;
        if (offset >= total) return new bytes32[](0);
        uint256 end = offset + limit > total ? total : offset + limit;
        bytes32[] memory result = new bytes32[](end - offset);
        for (uint256 i = 0; i < end - offset; i++) result[i] = allProjects[offset + i];
        return result;
    }

    function isCommitRecorded(bytes32 projectId, bytes32 commitHash) external view returns (bool) {
        return commitExists[projectId][commitHash];
    }

    function getCommitCount(bytes32 projectId) external view returns (uint256) {
        return projectCommits[projectId].length;
    }
}
